n &= n-1 直接去掉二进制中位置最靠后的1


常使用的算法:
    链表:
        链表的题先来个哑指针
    双指针
    动态规划
        // j-1表示的是过去的状态，i+1表示的是未来的状态，所以先遍历j
        dp[i][j] = dp[i+1][j-1];   // 回文的状态转移
    快慢指针 常用在链表
    优先队列：
        最大优先队列，无论入队顺序，当前最大的元素优先出队。
        最小优先队列，无论入队顺序，当前最小的元素优先出队。
        遍历过程中需要大小
    有序集合：treeset
        有序集合内的数据是有序的，可以根据key移除元素。
        函数ceiling(value)挺重要的，得到大于或等于value的那个最小的数
        有时候需要用到有序数组，可以用ceiling方便的得到想要的数。例如力扣220
        本质是利用有序数组的二分法来优化

    回溯算法

    滑动窗口

    二分法：
        类似于：如果数组 A 和 B 有一个长度为 k 的公共子数组，那么它们一定有长度为 j <= k 的公共子数组。这样我们可以通过二分查找的方法找到最大的 k。
        可以确定出一个具体的上下界。还有送包裹的题（1011题），最大的运输能力在包裹的总数和包裹的最大值之间即可用二分法

    栈结构
        单调栈：
        翻转
    队列结构

    接雨水的题:
        从左往右遍历一遍，从右往左遍历一遍，确认左右边界
        s还可以使用双指针确定

    摩尔投票法：找众数

    费马平方和定理: 633
        一个非负整数 cc 如果能够表示为两个整数的平方和，当且仅当 cc 的所有形如 4k + 34k+3 的质因子的幂均为偶数。

二叉树:
    树的入度出度概念 331

可以用一个数组保存出现的次数，比如字母的次数，只有26的字母，所以只需要26位大小的数组即可
还可以通过32位的数组保存数字的位关系，比如除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。这样出现3次的数字对应的位就能整除3 （137题）


HashMap常用的函数
    Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
    freq.put(num, freq.getOrDefault(num, 0) + 1);
    for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
        int num = entry.getKey(), occ = entry.getValue();
    }