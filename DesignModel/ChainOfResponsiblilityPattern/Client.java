package DesignModel.ChainOfResponsiblilityPattern;

/**
 * 责任链模式的优点
 * 责任链模式非常显著的优点是将请求和处理分开。 请求者可以不用知道是谁处理的， 处
 * 理者可以不用知道请求的全貌（例如在J2EE项目开发中， 可以剥离出无状态Bean由责任链处
 * 理） ， 两者解耦， 提高系统的灵活性。
 *
 * 责任链模式的缺点
 * 责任链有两个非常显著的缺点： 一是性能问题， 每个请求都是从链头遍历到链尾， 特别
 * 是在链比较长的时候， 性能是一个非常大的问题。 二是调试不很方便， 特别是链条比较长，
 * 环节比较多的时候， 由于采用了类似递归的方式， 调试的时候逻辑可能比较复杂。
 *
 * 责任链模式的注意事项
 * 链中节点数量需要控制， 避免出现超长链的情况， 一般的做法是在Handler中设置一个
 * 最大节点数量， 在setNext方法中判断是否已经是超过其阈值， 超过则不允许该链建立， 避免
 * 无意识地破坏系统性能
 *
 * 责任链模式屏蔽了请求的处理过程， 你发起一个请求到底是谁处理的， 这个你不用关
 * 心， 只要你把请求抛给责任链的第一个处理者， 最终会返回一个处理结果（当然也可以不做
 * 任何处理） ， 作为请求者可以不用知道到底是需要谁来处理的， 这是责任链模式的核心， 同
 * 时责任链模式也可以作为一种补救模式来使用。 举个简单例子， 如项目开发的时候， 需求确
 * 认是这样的： 一个请求（如银行客户存款的币种） ， 一个处理者（只处理人民币） ， 但是随
 * 着业务的发展（改革开放了嘛， 还要处理美元、 日元等） ， 处理者的数量和类型都有所增
 * 加， 那这时候就可以在第一个处理者后面建立一个链， 也就是责任链来处理请求， 如果是人
 * 民币， 好， 还是第一个业务逻辑来处理； 如果是美元， 好， 传递到第二个业务逻辑来处理；
 * 日元、 欧元……这些都不用在对原有的业务逻辑产生很大改变， 通过扩展实现类就可以很好
 * 地解决这些需求变更的问题。
 *
 * 责任链在实际的项目中使用也是比较多的， 我曾经做过这样一个项目， 界面上有一个用
 * 户注册功能， 注册用户分两种， 一种是VIP用户， 也就是在该单位办理过业务的， 一种是普
 * 通用户， 一个用户的注册要填写一堆信息， VIP用户只比普通用户多了一个输入项： VIP序列
 * 号。 注册后还需要激活， VIP和普通用户的激活流程也是不同的， VIP是自动发送邮件到用户
 * 的邮箱中就算激活了， 普通用户要发送短信才能激活， 为什么呢？ 获得手机号码以后好发广
 * 告短信啊！ 项目组就采用了责任链模式， 甭管从前台传递过来的是VIP用户信息还是普通用户信息，
 * 统一传递到一个处理入口， 通过责任链来完成任务的处理，
 */
public class Client {
    public static void main(String[] args) {
        Handler handler1 = new ConcreteHandler1();
        Handler handler2 = new ConcreteHandler2();
        Handler handler3 = new ConcreteHandler3();
        handler1.setNextHandler(handler2);
        handler2.setNextHandler(handler3);
        //设置链中的阶段顺序1-->2-->3
        Request request = new Request(Level.DIFF, "born");
        // 当1不能处理，会交给2进行处理，以此类推
        handler1.handleMessage(request);
    }
}
